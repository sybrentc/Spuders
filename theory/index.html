<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower defence theory</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Latin+Modern+Roman&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous">
    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
    <!-- Include Plotly.js -->
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
    <style>
        body { font-family: 'Latin Modern Roman', serif; font-size: 1.1em; line-height: 1.6; padding: 2em; max-width: 800px; margin: auto; }
        .katex { font-size: inherit; } /* Make KaTeX inherit body font size */
        .katex-display { display: block; margin: 1em 0; text-align: center; }
        h1 { text-align: center; }
    </style>
</head>
<body>

<h1>Tower-defence theory</h1>

<p style="text-align: center; font-size: 0.9em; margin-top: 0.5em; margin-bottom: 1.5em;">
    Dr. S. ten Cate<sup>*</sup>, Dr. H. Guo, M. B. ten Cate, S. ten Cate<br>
    <sup>*</sup>Corresponding author: <a href="mailto:s.tencate@outlook.com" style="color: inherit; text-decoration: none;">s.tencate@outlook.com</a>
</p>

<h2>Wave composition</h2>

<p>We generate waves of enemies according to an increasing difficulty score. The difficulty score \(W_n\) of a given wave \(n\) is given by the geometric series:</p>

\[ W_n = W_1 f^{n-1} \tag{1} \]

<p>This gives the total difficulty for a given wave such that we get waves of exponentially increasing difficulty. To now turn this into a selection of enemies for the wave, we assign each enemy type \(i\) a difficulty score \(w_i\). We assert that an enemy is more difficult to defeat the greater its speed \(s_i\) and health \(h_i\). Since the difficulty has an arbitrary scale, we simply assign the per-enemy difficulty score for type \(i\) as \(w_i = h_i s_i\). The total difficulty score of the wave is the sum of the difficulty scores of all the enemy types in the wave.</p>

\[ \sum_{i=1}^{N} (h_i s_i) = W_1 f^{n-1} \tag{2} \]

<p>We then select the enemy types for the wave such that the sum of the difficulty scores of the selected enemy types equals the total difficulty score of the wave.</p>

<p>The selection of enemies for a given wave is done as follows. First, we divide the total wave difficulty by the total number of enemy types to obtain a partial difficulty. The idea is to evenly distribute the total wave difficulty across the enemy types, such that we have more weaker enemies and fewer stronger enemies. Then we determine the number of enemies of each needed to make up that partial difficulty. Let \(W_n\) be the total wave difficulty, \(N\) be the number of enemy types considered, and \(w_i\) be the difficulty of enemy type \(i\). The initial count \(K_i\) for each type \(i\) is:</p>
\[ K_i = \left\lceil \frac{W_n / N}{w_i} \right\rceil \tag{3} \]
<p>If the number \(K_i\) exceeds a threshold number, \(K_{max}\), then we exclude that enemy type from the wave, while ensuring that we keep at least a given number of enemy types with the highest difficulty. This ensures that harder waves are not overwhelmed by weak enemies, but equally that harder waves are guaranteed to have at least a minimum number of the most difficulty enemy types. After excluding enemies, we recalculate partial difficulty and enemy numbers based on the remaining types. This prepopulates the wave. We then check whether we are over or above the target difficulty and add or remove enemies until we are within tolerance.</p>

<h2>Wave release</h2>

<p>We then time the release of enemies such that we achieve maximum density at the average death coordinate of the previous wave, \(d\). This is a proxy of the location along the path where the player has its strongest defences. To give the next wave a better chance of breaking through, we calculate release times for enemies of each type \(i\) so that the center of mass of each group arrives at \(d\) simultaneously. Let \(K_i\) be the number of enemies of type \(i\) in the wave and \(\Delta t\) be the average time between spawning enemies within a group. The time offset \(t_{o, i}\) for enemies of type \(i\) is the time it takes for the centre of mass of that train of enemies to be 'spawned'.</p>
\[ t_{o, i} = \frac{(K_i - 1) \Delta t}{2} \tag{4} \]
<p>The total time for the center of mass of type \(i\) to arrive at the target distance \(d\), if spawning started at \(t=0\), is the sum of its travel time \((d/s_i)\) and its offset time \(t_{o, i}\):</p>
\[ t_{COM, i} = \frac{d}{s_i} + t_{o, i} \tag{5} \]
<p>To ensure all groups' centers of mass arrive simultaneously, the start time \(t_{s, i}\) for spawning the first enemy of type \(i\) must be offset relative to the group that takes the longest to arrive. Thus, the start time is the maximum arrival time minus the arrival time for the specific type \(i\), at which time a train of enemies of type \(i\) is spawned with interval \(\Delta t\).</p>
\[ t_{s, i} = \max_{j} (t_{COM, j}) - t_{COM, i} \tag{6} \]

<h2>Defender valuation</h2>

<p>We price defenders based on their expected earning rate. This gives algorithmically determined defender prices, which reflect their usefulness against enemies. Defenders will earn bounty by killing enemies. So, we set the defender's cost, \(C\), proportional to its expected earning rate, \(R\), using a tunable pre-factor, \(\alpha\).</p>

\[ C = \alpha R \tag{7} \]

<p>Now, to calculate the expected earning power of a given defender, we start simply with the case of a single defender of a given type versus a single enemy of a given type. Once we have that, then we can use an expectation value across all enemy types to get the expected earning power of that defender.</p>

<p>So, say we have a single defender versus a single enemy. We can then set up a probability chain similar to the Drake equation to find the earning rate \(R\) for this specific pairing. We start with the ideal earning rate, \(R^*\), which assumes the defender has the enemy in range until it kills the enemy and obtains the bounty. We then multiply this ideal rate by the probability that the enemy is in range, \(P(\text{in range})\), and by the probability that the kill completes while the enemy is still in range, \(P(\text{kill completes})\).</p>

\[ R = R^* P(\text{in range}) P(\text{kill completes}) \tag{8} \]

<p>The ideal earning rate, \(R^*\), is simply the enemy bounty, \(B\), divided by the time it takes the defender to kill the enemy, \(T_k\). While the bounty \(B\) can be set manually, it can also be algorithmically determined based on enemy properties, for example, making it proportional (via a constant \(\beta\)) to the enemy's speed \(s\) and health \(h\). The time to kill, \(T_k\), depends on the enemy health \(h\), the defender's damage per hit \(D\), and the defender's attack rate \(r\). Specifically, we need the number of hits required, which is the health divided by damage, rounded up to the nearest integer (ceiling function), divided by the attack rate. This ideal earning rate assumes an enemy is in range of the defender and that it stays in range until the kill completes.</p>

\[ R^* = \frac{B}{T_k} \tag{9} \]
\[ B = \beta s h \tag{10} \]
\[ T_k = \left\lceil \frac{h}{D} \right\rceil / r \tag{11} \]

<p>Next, we need to calculate \(P(\text{kill completes})\). This probability accounts for the fact that an enemy moves through the range, so will only stay in range for a limited time, \(T_r\). If the time in range is shorter than the time to kill \(T_k\), then the defender cannot complete the kill. However, the defender can reduce the enemy health by a percentage. We can choose to consider that health reduction a probability to complete the kill, since we can choose to view a 100% chance of a 50% health reduction as mathematically equivalent to a 50% chance of a 100% health reduction. The time in range can be expressed in terms of the total path length \(L\).</p>

\[ P(\text{kill completes}) = \min\left( \frac{T_r}{T_k}, 1 \right) \tag{12} \]
\[ T_r = P(\text{in range}) \frac{L}{s} \tag{13} \]

<p>Now, as mentioned in the above, this gives the earning rate of a single defender type against a single enemy type.</p>

\[ C = \alpha B P(\text{in range}) \frac{r}{\left\lceil \frac{h}{D} \right\rceil} \min\left( \frac{P(\text{in range}) L r}{s \left\lceil \frac{h}{D} \right\rceil}, 1 \right) \tag{14} \]

<p>We can then take the expectation value for the cost of this defender type by multiplying the cost \(C_j\) (calculated using Eq. 12 for each enemy type \(j\) with its specific health \(h_j\) and speed \(s_j\)) by the probability \(P(j)\) of spawning that enemy type, and summing over all \(N\) enemy types. Assuming equal probability \(P(j)=1/N\) for all types, and using the equation for the per-enemy bounty \(B\), this yields the expected cost \(\mathbb{E}[C]\):</p>

\[ \mathbb{E}[C] = \frac{\alpha \beta P(\text{in range}) r}{N} \sum_{j=1}^{N} \left[ \frac{s_j h_j}{\lceil h_j/D \rceil} \min\left( \frac{P(\text{in range}) L r}{s_j \lceil h_j/D \rceil}, 1 \right) \right] \tag{15} \]

<p>The result provides a way of automatically setting the defender cost based on the path shape, the defender properties (range, damage per hit, attack rate), and the enemy properties (health, speed). The tower-defence economy can be tuned via the alpha pre-factor, which is a proxy of gameplay difficulty. Set alpha to zero and the game becomes trivially easy to win as all defenders are practically free to purchase. Set alpha very high and the game becomes impossible to win, as enemy bounties cannot support the sustained investment in defences required to keep up with enemy waves of increasing difficulty. The beta pre-factor offers a way to scale the unit of currency but has no impact on game mechanics.</p>

<h2>Path coverage</h2>

<p>To calculate P(in range), we simply ask what the probability is that an enemy, placed at random along its path of attack, is in range of the defender. Since the enemy traverses the path at uniform speed, this simplifies to asking what fraction of the path is in range of the defender. Of course, we don't know where the defender is going to be placed, but the player will place it somewhere along the path. We first sample a number of positions on the path, for each position obtaining the path length in range of the defender. The path length in range is obtained by substituting the parametrised line equation for that segment into the circle equation for that defender position and solving it using the quadratic formula. The on-path location which maximises in-range path length is then used as a starting point for a gradient descent to explore whether a more optimal position may be found off-path. This is carried out in a pre-calculation step and stored as a look-up table. For our given path shape, the result looks as follows</p>

<div style="max-width: 600px; margin: 2em auto;">
    <div id="pathCoveragePlot"></div> <!-- Plotly targets divs -->
</div>
<p style="text-align: center; font-size: 0.9em;">Figure 1: Path coverage fraction vs. defender range.</p>

<p>The graph shows a few different regimes. The first regime starts at a range equal to the size of the exclusion zone, i.e., the distance from the path within which no defenders may be placed. Any defender with a range of that size or less could not achieve overlap with the path. To first-order approximation, the overlap grows linearly with range in the first regime. This regime is indicated on the map below by red dots. In this regime, defenders need to be placed in 'hot spots', corresponding to parts of the path with high radii of curvature. Note that our path has a complex winding part and a straight part, we can refer to these as the knot and the string. The second regime occurs when the range gets large enough that we no longer need to concern ourselves with the complex winding part of the path, since the entire knot falls within range. This marks the start of the second regime, indicated by blue dots on the map below. Here, the optimal defender positions are not in hot spots but seem to follow a centre of mass approach, capturing the knot in all cases while expanding range to capture more additional string as well. The second regime transitions into the third regime around the range corresponding to the theoretical minimum radius of a freely placed circle which covers our path entirely. The third regime corresponds to a full coverage of the entire path. The following map shows the calculated optimal defender positions for range values up to 500 pixels. Larger ranges have wider error bars on their optimal positions and are therefore less informative.</p>
<div id="mapContainer" style="position: relative; width: 600px; height: 600px; margin: 2em auto; border: 1px solid #ccc;">
    <img id="mapImage" src="../assets/images/map.png" alt="Game Map" style="display: block; width: 100%; height: 100%; object-fit: contain;">
    <canvas id="optimumPositionsCanvas" width="600" height="600" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
</div>
<p style="text-align: center; font-size: 0.9em;">Figure 2: Optimal defender placement positions. Red dots are below a threshold range; blue dots above it. The blue circle indicates the smallest defender range in the second regime, centred on its optimum position. Note that the blue circle covers the complex turns of the path almost entirely.</p>
<!-- End Map Visualization Section -->

<h2>Break-even condition</h2>

<p>The tower defence game at its core involves an ever-escalating balance between stronger waves and stronger defences. The game is balanced, i.e., at break-even condition, when the total defender earning rate equals the rate at which the wave provides bounty, If the latter dominates, the enemies cannot be cleared before they reach the base and we spiral toward defeat. If the former dominates, then the game enters a runaway win condition. To quantify game balance, we introduce the ratio \(g_n\) of earning rate to bounty rate for wave \(n\)</p>

\[ g_n = \frac{R_n}{b_n}. \tag{16} \]

<p>The earning rate \(R_n\) is that which the player could achieve if all available funds were invested by the start of wave \(n\), and is obtained using the cost equation (7). The funds in question are the initial funds, \(B_0\), plus the sum of bounties collected from all preceding waves. The bounty rate \(b_n\) in turn is defined as the total bounty \(B_n\) offered by wave \(n\) divided by the effective duration \(T_n\) over which it is available for harvesting, i.e., \(b_n = B_n / T_n\). This yields</p>

\[ g_n = \frac{T_n}{\alpha B_n} \left(B_0 + \sum_{j=1}^{n-1} B_j\right). \tag{17} \]

<p>From its definition (eqt. 7), the pre-factor \(\alpha\) sets gameplay difficulty by linking defender cost to earning rate (the latter a proxy of killing rate). We can calculate the theoretical break-even point \(\alpha_0\) at which the resources generated from completing wave \(n\) exactly pay for the required additional defence investment needed to survive the next wave, \(n+1\). Let \(T_0\) represent the time window available for clearing enemies as they traverse the path and before they reach the base. For the purpose of this derivation, we define this characteristic time window as being constant from wave to wave. If an earning rate of \(R_n\) was sufficient to just clear the enemies within the time window, then, since each wave grows in difficulty by a factor \(f\), in order to clear the next wave requires an earning rate scaled by \(f\) as well, i.e., \( R_{n+1} = f R_n \), and to buy this additional earning rate costs</p>
\[ \Delta C = \alpha (f - 1) R_n \tag{18} \]
<p>Since we are operating at break-even condition, we have cleared wave \(n\) in exactly time \(T_0\), meaning that the total bounty of the wave is set equal to \(R_n T_0\). This makes the break-even value for \(\alpha_0\)</p>

\[ \alpha_0 = \frac{T_0}{f - 1} \tag{19} \]
    
<p>Substituting this into eqt. 17, we get</p>

\[ g_n = \frac{T_n(f-1)}{T_0B_n} \left(B_0 + \sum_{j=1}^{n-1} B_j\right). \tag{20} \]

<p>Since the sum of the bounty terms \(B_n\) is a finite sum of a geometric series (cf. eqt. 1), this simplifies to the following expression for the ratio \(g_n\) in terms of the initial funds \(B_0\), the wave starting difficulty \(W_1\), the difficulty increase factor \(f\), the actual wave duration \(T_n\), the prefactor \(\beta\), and the break-even time window \(T_0\)</p>

\[ g_n = \frac{T_n}{T_0} \left[ 1 + \frac{(f-1) \left(\frac{B_0}{\beta W_1}\right) - 1}{f^{n-1}} \right]. \tag{21} \]

<p>We can approximate \(T_0\) as \(L / s_{min}\). Regarding the wave duration \(T_n\), this is the time interval from the moment the first enemy of wave \(n\) spawns until the very last enemy of that wave completes the path of length \(L\). The duration depends on the coordinated spawning of eqts. 4-6, which calculates a start time \(t_{s,i}\) for each enemy group \(i\) (containing \(K_i\) enemies of speed \(s_i\)) such that at least one group starts at \(t=0\). This results in</p>
\[ T_n = \max_{i} \left( t_{s,i} + (K_i - 1) \Delta t + \frac{L}{s_i} \right). \tag{22} \]

<p>We can calculate the starting funds \(B_0\) required to commence at break-even conditions by setting \(g_1 = 1\) in eqt. 21. In practice, the starting funds will be set somewhat above this minimum to account for the fact that defenders have discrete prices and the player cannot perfectly convert all of their funds into defensive power at every wave.</p>

\[ B_0 = \frac{T_0 \beta W_1}{T_1 (f-1)} \tag{23} \]

<p>The following figure shows the theoretical ratio \(g_n\) as defined by the above equations compared to a numerical simulation of the game mechanics. Deviations at low wave numbers are due to the game dealing with integer numbers of enemies, whereas the theoretical ratio is a continuum expression.</p>

<div style="max-width: 600px; margin: 2em auto;">
    <div id="endgameRatioPlot"></div> <!-- Plotly targets divs -->
</div>
<p style="text-align: center; font-size: 0.9em;">Figure 3: Ratio of earning rate to bounty rate versus wave number.</p>

<!-- Script to fetch data and render plot with Plotly.js -->
<script>
  const plotDiv = document.getElementById('pathCoveragePlot');

  // Function to fetch and parse path coverage CSV
  function fetchPathCoverageData() {
      return fetch('../assets/paths/path-coverage.csv')
          .then(response => {
              if (!response.ok) {
                  throw new Error(`HTTP error fetching coverage data! status: ${response.status}`);
              }
              return response.text();
          })
          .then(csvText => {
              const lines = csvText.trim().split('\n');
              const xData = [];
              const yData = [];
              for (let i = 1; i < lines.length; i++) { // Skip header
                  const columns = lines[i].split(',');
                  if (columns.length === 2) {
                      const range = parseInt(columns[0]);
                      const coverage = parseFloat(columns[1]);
                      if (!isNaN(range) && !isNaN(coverage)) {
                          xData.push(range);
                          yData.push(coverage);
                      }
                  }
              }
              return { xData, yData };
          });
  }

  // Function to fetch level data JSON
  function fetchLevelData() {
      return fetch('../assets/level1.json') // Fetch level1.json
          .then(response => {
              if (!response.ok) {
                  throw new Error(`HTTP error fetching level data! status: ${response.status}`);
              }
              return response.json();
          });
  }

  // Use Promise.all to wait for both fetches
  Promise.all([fetchPathCoverageData(), fetchLevelData()])
    .then(([coverageData, levelData]) => {
      // Both fetches succeeded, data is available here
      const { xData, yData } = coverageData;
      const exclusionRadius = levelData?.pathExclusionRadius;

      if (typeof exclusionRadius !== 'number') {
          throw new Error('pathExclusionRadius not found or not a number in level1.json');
      }

      // Define endpoints for the reference line directly
      const linearX = [exclusionRadius, mapRangeThreshold];
      const linearY = [0, 0.72];

      const trace1 = {
          x: xData,
          y: yData,
          mode: 'lines',
          type: 'scatter',
          name: 'Coverage Fraction',
          line: { color: 'rgb(75, 192, 192)' },
          cliponaxis: false
      };

      const trace2 = {
          x: linearX, // Use the 2-point array
          y: linearY, // Use the 2-point array
          mode: 'lines',
          type: 'scatter',
          name: 'Linear reference',
          line: { color: 'black', width: 1.5 },
          cliponaxis: false
      };

      const layout = {
          font: { family: "'Latin Modern Roman', serif", size: 14 },
          xaxis: {
              title: 'Defender range (pixels)',
              range: [0, 1000],
              dtick: 200,
              titlefont: { family: "'Latin Modern Roman', serif" },
              tickfont: { family: "'Latin Modern Roman', serif" },
              showline: true,
              linecolor: 'black',
              linewidth: 1,
              mirror: true
          },
          yaxis: {
              title: 'Fraction of path in range',
              range: [0, 1.05],
              dtick: 0.2,
              titlefont: { family: "'Latin Modern Roman', serif" },
              tickfont: { family: "'Latin Modern Roman', serif" },
              showline: true,
              linecolor: 'black',
              linewidth: 1,
              mirror: true
          },
          margin: { l: 50, r: 20, t: 30, b: 50, pad: 0 },
          showlegend: true,
          legend: {
              font: { family: "'Latin Modern Roman', serif" },
              x: 0.05,
              y: 0.95,
              xanchor: 'left',
              yanchor: 'top'
          },
          layer: 'below traces',
          shapes: [
            {
              type: 'line',
              x0: 733,
              y0: 0,
              x1: 733,
              y1: 1.05,
              yref: 'y',
              line: {
                color: 'black', // Changed from grey to black
                width: 2,
                dash: 'dash'
              }
            },
            {
              type: 'line',
              x0: exclusionRadius, // Use fetched value
              y0: 0,
              x1: exclusionRadius, // Use fetched value
              y1: 1,
              yref: 'paper',
              line: {
                color: 'black', // Changed from red to black
                width: 2,
                dash: 'dash'
              }
            },
            {
              // New line for the specified range threshold
              type: 'line',
              x0: mapRangeThreshold, // Use variable
              y0: 0,
              x1: mapRangeThreshold, // Use variable
              y1: 1,
              yref: 'paper',
              line: {
                color: 'black',
                width: 2,
                dash: 'dash'
              }
            }
          ]
      };

      Plotly.newPlot(plotDiv, [trace1, trace2], layout);
    })
    .catch(error => {
      // Handle errors from either fetch or processing
      console.error('Error fetching data or rendering plot:', error);
      if (plotDiv) {
          let errorMsgElement = plotDiv.querySelector('.chart-error-msg');
          if (!errorMsgElement) {
              errorMsgElement = document.createElement('p');
              errorMsgElement.style.color = 'red';
              errorMsgElement.classList.add('chart-error-msg');
              plotDiv.appendChild(errorMsgElement);
          }
          errorMsgElement.textContent = 'Error loading chart: ' + error.message + '. Check console.';
      }
    });

  // --- Script for Map Visualization ---
  const mapImage = document.getElementById('mapImage');
  const mapCanvas = document.getElementById('optimumPositionsCanvas');
  const mapCtx = mapCanvas.getContext('2d');
  const optimalPosDataPath = '../assets/paths/path-optimums.csv';
  const mapRangeThreshold = 468; // Define threshold variable here

  // Ensure image is loaded before drawing (important for dimensions if not hardcoded)
  mapImage.onload = () => {
      console.log("Map image loaded. Fetching optimum positions...");
      fetchOptimalPositions(mapRangeThreshold); // Pass variable
  };
  // Handle cases where image might already be loaded (e.g., from cache)
  if (mapImage.complete && mapImage.naturalHeight !== 0) {
       console.log("Map image already complete. Fetching optimum positions...");
       fetchOptimalPositions(mapRangeThreshold); // Pass variable
  }
  mapImage.onerror = () => {
      console.error("Failed to load map image:", mapImage.src);
      const mapContainer = document.getElementById('mapContainer');
      if(mapContainer){
          mapContainer.innerHTML = '<p style="color:red;">Error loading map image. Check path and console.</p>';
      }
  }

  // Use async function to handle fetching dependencies sequentially
  // Accept threshold as an argument
  async function fetchOptimalPositions(threshold) { 
      try {
          // --- Fetch level data first ---
          const levelResponse = await fetch('../assets/level1.json');
          if (!levelResponse.ok) {
              throw new Error(`HTTP error fetching level data! status: ${levelResponse.status}`);
          }
          const levelData = await levelResponse.json();
          const exclusionRadius = levelData?.pathExclusionRadius;

          if (typeof exclusionRadius !== 'number') {
              throw new Error('pathExclusionRadius not found or not a number in level1.json');
          }
          // ---------------------------

          // --- Now fetch optimum positions ---
          const optimumsResponse = await fetch(optimalPosDataPath);
          if (!optimumsResponse.ok) {
              throw new Error(`HTTP error fetching optimum positions! status: ${optimumsResponse.status} - Check path: ${optimalPosDataPath}`);
          }
          const csvText = await optimumsResponse.text();
          // -----------------------------

          const positions = [];
          const lines = csvText.trim().split('\n');
          // Skip header
          for (let i = 1; i < lines.length; i++) {
              const columns = lines[i].split(',');
              if (columns.length === 3) {
                  const range = parseInt(columns[0]); // Parse range
                  const x = parseFloat(columns[1]);
                  const y = parseFloat(columns[2]);
                  if (!isNaN(range) && !isNaN(x) && !isNaN(y)) {
                      positions.push({ range, x, y }); // Store range, x, y
                  }
              }
          }
          // Filter using only the lower bound (exclusionRadius)
          const filteredPositions = positions.filter(pos => pos.range > exclusionRadius);

          // Sort by range to find the first one >= threshold
          filteredPositions.sort((a, b) => a.range - b.range);
          const targetPosition = filteredPositions.find(pos => pos.range >= threshold);

          // Pass the target position (or undefined if not found) to the drawing function
          drawOptimalPositions(filteredPositions, threshold, targetPosition); 

      } catch (error) {
          // --- Unified error handling ---
          console.error('Error fetching data or processing positions:', error);
          mapCtx.fillStyle = 'red';
          mapCtx.font = '12px sans-serif';
          mapCtx.fillText('Error loading optimal positions. See console.', 10, 20);
          // --------------------------
      }
  }

  function drawOptimalPositions(positions, rangeThreshold, targetPosition) {
      // Define original (data) and display dimensions
      const originalWidth = 1024;
      const originalHeight = 1024;
      const displayWidth = 600;
      const displayHeight = 600;

      // Set canvas size explicitly
      mapCanvas.width = displayWidth;
      mapCanvas.height = displayHeight;
      
      mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height); // Clear previous drawings
      const dotRadius = 2; // Size of the position dots

      // Calculate scaling factors
      const scaleX = displayWidth / originalWidth;
      const scaleY = displayHeight / originalHeight;

      // --- Draw all the position dots first ---
      positions.forEach(pos => {
          if (pos.range < rangeThreshold) {
              mapCtx.fillStyle = 'red';
          } else {
              mapCtx.fillStyle = 'blue';
          }
          const scaledX = pos.x * scaleX;
          const scaledY = pos.y * scaleY;
          mapCtx.beginPath();
          mapCtx.arc(scaledX, scaledY, dotRadius, 0, 2 * Math.PI);
          mapCtx.fill(); 
      });
      // --- End drawing dots ---
       
      // --- Draw the target circle outline --- 
      if (targetPosition) {
          console.log("Drawing target circle for range:", targetPosition.range);
          const scaledCenterX = targetPosition.x * scaleX;
          const scaledCenterY = targetPosition.y * scaleY;
          // Scale the radius using the same factor as x-coordinates (assuming uniform scaling)
          const scaledRadius = targetPosition.range * scaleX; 

          mapCtx.beginPath();
          mapCtx.arc(scaledCenterX, scaledCenterY, scaledRadius, 0, 2 * Math.PI);
          mapCtx.strokeStyle = 'blue'; // Blue outline
          mapCtx.lineWidth = 1; // Thin outline
          mapCtx.stroke(); // Draw the outline, don't fill
      }
      // --- End drawing circle --- 
      
      console.log(`Finished drawing optimal positions. Threshold: ${rangeThreshold}px`);
  }
  // --------------------------------

  // --- Script for Endgame Ratio Plot ---
  const endgamePlotDiv = document.getElementById('endgameRatioPlot');
  const analysisDataPath = '../assets/waves/analysis-results.json';
  const baseDataPath = '../assets/base.json';
  const level1DataPath = '../assets/level1.json';
  const waveParamsPath = '../assets/waves/waves.json';
  const pathStatsPath = '../assets/paths/path-stats.json';

  // Function to fetch a JSON file
  function fetchJson(path) {
    return fetch(path).then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error fetching ${path}! status: ${response.status}`);
      }
      return response.json();
    });
  }

  // Fetch all necessary data in parallel
  Promise.all([
    fetchJson(analysisDataPath), // Existing analysis results
    fetchJson(baseDataPath),
    fetchJson(level1DataPath),
    fetchJson(waveParamsPath),
    fetchJson(pathStatsPath)
  ])
  .then(async ([analysisResults, baseData, level1Data, waveParams, pathStats]) => {
    // We need enemy data too, path is in level1Data
    const enemyDataPath = `../${level1Data.enemyData}`;
    const enemiesData = await fetchJson(enemyDataPath);

    // Extract parameters for theoretical calculation
    const B0 = baseData.stats.money;
    const beta = level1Data.currencyScale;
    const W1 = waveParams.startingDifficulty;
    const f = waveParams.difficultyIncreaseFactor;
    const L = pathStats.totalPathLength;
    const dt_ms = waveParams.delayBetweenEnemiesMs;
    const dt_seconds = dt_ms / 1000.0;

    const enemies = enemiesData; // Directly use the fetched array
    if (!Array.isArray(enemies) || enemies.length === 0) {
      throw new Error('No enemy data found or in unexpected format.');
    }
    
    const enemyStats = enemies.map(e => ({ 
      speed: e.stats.speed, 
      hp: e.stats.hp, 
      w: e.stats.speed * e.stats.hp // Precalculate difficulty w_i
    }));
    const N = enemyStats.length;
    const s_min = Math.min(...enemyStats.map(e => e.speed));
    if (s_min <= 0) {
        throw new Error('Slowest enemy speed must be positive.');
    }
    const T0 = L / s_min;

    // --- Calculate T1 and Theoretical B0 for g1=1 --- 
    const T1 = calculateTheoreticalTn(1, W1, f, enemyStats, L, dt_seconds, waveParams);
    let B0_theoretical;
    if (T1 > 0 && f > 1 && beta > 0 && W1 > 0) { 
        B0_theoretical = (T0 * beta * W1) / (T1 * (f - 1));
        console.log(`Calculated theoretical B0 for g1=1: ${B0_theoretical.toFixed(2)}`);
    } else {
        console.warn(`Cannot calculate theoretical B0: T0=${T0}, T1=${T1}, f=${f}, beta=${beta}, W1=${W1}. Using original B0.`);
        B0_theoretical = baseData.stats.money; // Fallback if calculation failed
    }
    // ------------------------------------ 

    // --- Use B0 from the file for the main theoretical line --- 
    const B0_from_file = baseData.stats.money; // Use original B0 reading
    const B0_to_use_main = B0_from_file; // Use the B0 from the file for the solid theoretical line
    console.log("Using B0 from file for solid line:", B0_to_use_main); 
    // ------------------------------------ 

    // --- Function to calculate theoretical Tn ---
    // Incorporates enemy exclusion logic based on maxPrepopulationPerType and minEnemyTypes
    function calculateTheoreticalTn(n, W1, f, enemyStats, L, dt_seconds, waveParams) {
        const Wn = W1 * Math.pow(f, n - 1);
        const N = enemyStats.length;
        const K_max = waveParams.waveGeneration.maxPrepopulationPerType;
        const min_strongest_types = waveParams.waveGeneration.minEnemyTypes;

        if (N === 0) return 0; // No enemies, duration is 0

        // 1. Initial Ki calculation & Sort enemies by difficulty (ascending)
        const enemiesWithInitialK = enemyStats.map((stats, index) => ({
            ...stats,
            originalIndex: index, // Keep track if needed
            K_initial: stats.w > 0 ? (Wn / N) / stats.w : Infinity // Avoid division by zero
        })).sort((a, b) => a.w - b.w);

        // 2. Identify whitelist (exclude weak enemies with K_initial > K_max)
        let whitelist = [...enemiesWithInitialK]; // Start with all
        const numToRemove = Math.max(0, N - min_strongest_types);
        let excludedCount = 0;

        // Iterate only through those eligible for removal
        for (let i = 0; i < numToRemove; i++) {
            if (enemiesWithInitialK[i].K_initial > K_max) {
                // Mark for exclusion (safer than modifying array while iterating)
                enemiesWithInitialK[i].exclude = true;
                excludedCount++;
            }
        }
        whitelist = enemiesWithInitialK.filter(e => !e.exclude);
        
        const N_wl = whitelist.length;
        if (N_wl === 0) return 0; // All enemies excluded?
        
        // 3. Recalculate K for whitelisted enemies based on redistributed difficulty
        const finalEnemyCalcs = whitelist.map(stats => {
             const K_final = stats.w > 0 ? (Wn / N_wl) / stats.w : 0;
             const Ki_eff = Math.max(0, K_final); // Effective number for timing
             const travel_time = L / stats.speed;
             // Spawn offset: time for COM of Ki_eff enemies to be spawned
             const t_offset = Ki_eff > 1 ? (Ki_eff - 1) * dt_seconds / 2 : 0;
             // COM arrival time at d = L/2 (approximation)
             const t_com = (L / 2) / stats.speed + t_offset;
             return { Ki_eff, speed: stats.speed, t_com, travel_time };
        });

        // 4. Calculate Tn using final enemy calculations
        let t_com_max = 0;
        finalEnemyCalcs.forEach(calc => { t_com_max = Math.max(t_com_max, calc.t_com); });

        let Tn = 0;
        for (const calc of finalEnemyCalcs) {
            const t_start = t_com_max - calc.t_com;
            // Time last enemy finishes path = start_spawn + spawn_duration + travel_time
            const spawn_duration = calc.Ki_eff > 1 ? (calc.Ki_eff - 1) * dt_seconds : 0;
            const t_finish_last = t_start + spawn_duration + calc.travel_time;
            Tn = Math.max(Tn, t_finish_last);
        }
        
        return Tn;
    }
    // --- End Function --- 

    // Calculate theoretical g_n values for BOTH B0 scenarios
    const waves = analysisResults.map(d => d.wave);
    const ratios_simulated = analysisResults.map(d => d.ratio);
    const gn_theoretical_main = []; // For solid line (B0 from file)
    const gn_theoretical_g1_equals_1 = []; // For dashed line (calculated B0)

    for (const n of waves) {
        const Tn = calculateTheoreticalTn(n, W1, f, enemyStats, L, dt_seconds, waveParams);
        if (T0 <= 0 || Tn <= 0 || beta <= 0 || W1 <= 0) { 
             console.warn(`Skipping g_n calculation for wave ${n} due to non-positive T0=${T0}, Tn=${Tn}, beta=${beta}, or W1=${W1}`);
             gn_theoretical_main.push(NaN);
             gn_theoretical_g1_equals_1.push(NaN);
             continue;
        } 
        const denominator = Math.pow(f, n - 1);
        if (denominator === 0) {
             console.warn(`Skipping g_n calculation for wave ${n} due to zero denominator`);
             gn_theoretical_main.push(NaN);
             gn_theoretical_g1_equals_1.push(NaN);
             continue;
        }

        // Calculate g_n using B0 from file (for solid line)
        const term1_main = (f - 1) * (B0_to_use_main / (beta * W1)); 
        const numerator_main = term1_main - 1;
        const gn_main = (Tn / T0) * (1 + numerator_main / denominator);
        gn_theoretical_main.push(gn_main);

        // Calculate g_n using theoretical B0 (for dashed line)
        const term1_g1_equals_1 = (f - 1) * (B0_theoretical / (beta * W1)); 
        const numerator_g1_equals_1 = term1_g1_equals_1 - 1;
        const gn_g1_equals_1 = (Tn / T0) * (1 + numerator_g1_equals_1 / denominator);
        gn_theoretical_g1_equals_1.push(gn_g1_equals_1);
    }

    // Create Plotly traces
    const trace_simulated = {
      x: waves,
      y: ratios_simulated,
      mode: 'markers',
      type: 'scatter',
      name: 'Simulated g<sub>n</sub>',
      line: { color: 'rgb(219, 64, 82)' },
      marker: { size: 8 },
      cliponaxis: false
    };

    const trace_theoretical = {
      x: waves,
      y: gn_theoretical_main, // Use B0 from file
      mode: 'lines',
      type: 'scatter',
      name: 'Theoretical g<sub>n</sub> (larger starting funds)',
      line: { color: 'black', width: 2, dash: 'solid' },
      cliponaxis: false
    };

    const trace_theoretical_g1_equals_1 = {
      x: waves,
      y: gn_theoretical_g1_equals_1, // Use calculated B0
      mode: 'lines',
      type: 'scatter',
      name: 'Theoretical g<sub>n</sub> (break-even starting funds, i.e., g<sub>1</sub>=1)',
      line: { color: 'black', width: 2, dash: 'dash' }, // Dashed line
      cliponaxis: false
    };

    // Define Plotly layout
    const layout = {
      height: 500, // Explicitly set height
      font: { family: "'Latin Modern Roman', serif", size: 14 },
      xaxis: {
        title: 'Wave Number (n)',
        range: [0, Math.max(...waves) + 1],
        dtick: 5,
        titlefont: { family: "'Latin Modern Roman', serif" },
        tickfont: { family: "'Latin Modern Roman', serif" },
        showline: true,
        linecolor: 'black',
        linewidth: 1,
        mirror: true
      },
      yaxis: {
        title: 'Balance Ratio (g<sub>n</sub>)', // Updated label
        type: 'log',
        autorange: true,
        titlefont: { family: "'Latin Modern Roman', serif" },
        tickfont: { family: "'Latin Modern Roman', serif" },
        showline: true,
        linecolor: 'black',
        linewidth: 1,
        mirror: true
      },
      margin: { l: 70, r: 20, t: 30, b: 50, pad: 0 },
      showlegend: true, // Show legend
      legend: { 
          font: { family: "'Latin Modern Roman', serif" }, 
          x: 0.05, 
          y: 0.95, 
          xanchor: 'left', 
          yanchor: 'top' 
      },
      layer: 'below traces'
    };

    // Render the plot with all three traces
    Plotly.newPlot(endgamePlotDiv, [trace_simulated, trace_theoretical, trace_theoretical_g1_equals_1], layout);
  })
  .catch(error => {
    console.error('Error fetching data or rendering endgame plot:', error);
    if (endgamePlotDiv) {
      let errorMsgElement = endgamePlotDiv.querySelector('.chart-error-msg');
      if (!errorMsgElement) {
        errorMsgElement = document.createElement('p');
        errorMsgElement.style.color = 'red';
        errorMsgElement.classList.add('chart-error-msg');
        endgamePlotDiv.appendChild(errorMsgElement);
      }
      errorMsgElement.textContent = 'Error loading chart: ' + error.message + '. Check console.';
    }
  });
  // --- End Endgame Ratio Plot ---

</script>

<!-- Script to trigger KaTeX rendering -->
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '\\[', right: '\\]', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false}
      ],
      throwOnError : false
    });
  });
</script>

</body>
</html>