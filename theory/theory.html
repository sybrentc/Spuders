<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower defence theory</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Latin+Modern+Roman&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous">
    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
    <!-- Include Plotly.js -->
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
    <style>
        body { font-family: 'Latin Modern Roman', serif; font-size: 1.1em; line-height: 1.6; padding: 2em; max-width: 800px; margin: auto; }
        .katex { font-size: inherit; } /* Make KaTeX inherit body font size */
        .katex-display { display: block; margin: 1em 0; text-align: center; }
        h1 { text-align: center; }
    </style>
</head>
<body>

<h1>Tower-defence theory</h1>

<p style="text-align: center; font-size: 0.9em; margin-top: 0.5em; margin-bottom: 1.5em;">
    Dr. S. ten Cate<br>
    <a href="mailto:s.tencate@outlook.com" style="color: inherit; text-decoration: none;">s.tencate@outlook.com</a>
</p>

<h2>Wave composition</h2>

<p>We generate waves of enemies according to an increasing difficulty score. The difficulty score \(W_n\) of a given wave \(n\) is given by the initial difficulty \(W_0\) multiplied by a difficulty increase factor \(f\) raised to the power of the wave number \(n\):</p>
\[ W_n = W_0 f^n \tag{1} \]

<p>This gives the total difficulty for a given wave such that we get waves of exponentially increasing difficulty. To now turn this into a selection of enemies for the wave, we assign each enemy type \(i\) a difficulty score \(w_i\). We assert that an enemy is more difficult to defeat the greater its speed \(s_i\) and health \(h_i\). Since the difficulty has an arbitrary scale, we simply assign the per-enemy difficulty score for type \(i\) as \(w_i = h_i s_i\). The total difficulty score of the wave is the sum of the difficulty scores of all the enemy types in the wave.</p>

\[ \sum_{i=1}^{N} (h_i s_i) = W_0 f^n \tag{2} \]

<p>We then select the enemy types for the wave such that the sum of the difficulty scores of the selected enemy types equals the total difficulty score of the wave.</p>

<p>The selection of enemies for a given wave is done as follows. First, we divide the total wave difficulty by the total number of enemy types to obtain a partial difficulty. The idea is to evenly distribute the total wave difficulty across the enemy types, such that we have more weaker enemies and fewer stronger enemies. Then we determine the number of enemies of each needed to make up that partial difficulty. Let \(W_n\) be the total wave difficulty, \(N\) be the number of enemy types considered, and \(w_i\) be the difficulty of enemy type \(i\). The initial count \(K_i\) for each type \(i\) is:</p>
\[ K_i = \left\lceil \frac{W_n / N}{w_i} \right\rceil \tag{3} \]
<p>If the number \(K_i\) exceeds a threshold number, \(K_{max}\), then we exclude that enemy type from the wave, while ensuring that we keep at least a given number of enemy types with the highest difficulty. This ensures that harder waves are not overwhelmed by weak enemies, but equally that harder waves are guaranteed to have at least a minimum number of the most difficulty enemy types. After excluding enemies, we recalculate partial difficulty and enemy numbers based on the remaining types. This prepopulates the wave. We then check whether we are over or above the target difficulty and add or remove enemies until we are within tolerance.</p>

<h2>Wave release</h2>

<p>We then time the release of enemies such that we achieve maximum density at the average death coordinate of the previous wave, \(d\). This is a proxy of the location along the path where the player has its strongest defences. To give the next wave a better chance of breaking through, we calculate release times for enemies of each type \(i\) so that the center of mass of each group arrives at \(d\) simultaneously. Let \(K_i\) be the number of enemies of type \(i\) in the wave and \(\Delta t\) be the average time between spawning enemies within a group. The time offset \(t_{o, i}\) for enemies of type \(i\) is the time it takes for the centre of mass of that train of enemies to be 'spawned'.</p>
\[ t_{o, i} = \frac{(K_i - 1) \Delta t}{2} \tag{4} \]
<p>The total time for the center of mass of type \(i\) to arrive at the target distance \(d\), if spawning started at \(t=0\), is the sum of its travel time \((d/s_i)\) and its offset time \(t_{o, i}\):</p>
\[ t_{COM, i} = \frac{d}{s_i} + t_{o, i} \tag{5} \]
<p>To ensure all groups' centers of mass arrive simultaneously, the start time \(t_{s, i}\) for spawning the first enemy of type \(i\) must be offset relative to the group that takes the longest to arrive. Thus, the start time is the maximum arrival time minus the arrival time for the specific type \(i\), at which time a train of enemies of type \(i\) is spawned with interval \(\Delta t\).</p>
\[ t_{s, i} = \max_{j} (t_{COM, j}) - t_{COM, i} \tag{6} \]

<h2>Defender valuation</h2>

<p>We price defenders based on their expected earning rate. This gives algorithmically determined defender prices, which reflect their usefulness against enemies. Defenders will earn bounty by killing enemies. So, we set the defender's cost, \(C\), proportional to its expected earning rate, \(R\), using a tunable pre-factor, \(\alpha\).</p>

\[ C = \alpha R \tag{7} \]

<p>Now, to calculate the expected earning power of a given defender, we start simply with the case of a single defender of a given type versus a single enemy of a given type. Once we have that, then we can use an expectation value across all enemy types to get the expected earning power of that defender.</p>

<p>So, say we have a single defender versus a single enemy. We can then set up a probability chain similar to the Drake equation to find the earning rate \(R\) for this specific pairing. We start with the ideal earning rate, \(R^*\), which assumes the defender has the enemy in range until it kills the enemy and obtains the bounty. We then multiply this ideal rate by the probability that the enemy is in range, \(P(\text{in range})\), and by the probability that the kill completes while the enemy is still in range, \(P(\text{kill completes})\).</p>

\[ R = R^* P(\text{in range}) P(\text{kill completes}) \tag{8} \]

<p>The ideal earning rate, \(R^*\), is simply the enemy bounty, \(B\), divided by the time it takes the defender to kill the enemy, \(T_k\). While the bounty \(B\) can be set manually, it can also be algorithmically determined based on enemy properties, for example, making it proportional (via a constant \(\beta\)) to the enemy's speed \(s\) and health \(h\). The time to kill, \(T_k\), depends on the enemy health \(h\), the defender's damage per hit \(D\), and the defender's attack rate \(r\). Specifically, we need the number of hits required, which is the health divided by damage, rounded up to the nearest integer (ceiling function), divided by the attack rate. This ideal earning rate assumes an enemy is in range of the defender and that it stays in range until the kill completes.</p>

\[ R^* = \frac{B}{T_k} \tag{9} \]
\[ B = \beta s h \tag{10} \]
\[ T_k = \left\lceil \frac{h}{D} \right\rceil / r \tag{11} \]

<p>Next, we need to calculate \(P(\text{kill completes})\). This probability accounts for the fact that an enemy moves through the range, so will only stay in range for a limited time, \(T_r\). If the time in range is shorter than the time to kill \(T_k\), then the defender cannot complete the kill. However, the defender can reduce the enemy health by a percentage. We can choose to consider that health reduction a probability to complete the kill, since we can choose to view a 100% chance of a 50% health reduction as mathematically equivalent to a 50% chance of a 100% health reduction. The time in range can be expressed in terms of the total path length \(L\).</p>

\[ P(\text{kill completes}) = \min\left( \frac{T_r}{T_k}, 1 \right) \tag{12} \]
\[ T_r = P(\text{in range}) \frac{L}{s} \tag{13} \]

<p>Now, as mentioned in the above, this gives the earning rate of a single defender type against a single enemy type.</p>

\[ C = \alpha B P(\text{in range}) \frac{r}{\left\lceil \frac{h}{D} \right\rceil} \min\left( \frac{P(\text{in range}) L r}{s \left\lceil \frac{h}{D} \right\rceil}, 1 \right) \tag{14} \]

<p>We can then take the expectation value for the cost of this defender type by multiplying the cost \(C_j\) (calculated using Eq. 12 for each enemy type \(j\) with its specific health \(h_j\) and speed \(s_j\)) by the probability \(P(j)\) of spawning that enemy type, and summing over all \(N\) enemy types. Assuming equal probability \(P(j)=1/N\) for all types, and using the equation for the per-enemy bounty \(B\), this yields the expected cost \(\mathbb{E}[C]\):</p>

\[ \mathbb{E}[C] = \frac{\alpha \beta P(\text{in range}) r}{N} \sum_{j=1}^{N} \left[ \frac{s_j h_j}{\lceil h_j/D \rceil} \min\left( \frac{P(\text{in range}) L r}{s_j \lceil h_j/D \rceil}, 1 \right) \right] \tag{15} \]

<p>The result provides a way of automatically setting the defender cost based on the path shape, the defender properties (range, damage per hit, attack rate), and the enemy properties (health, speed). The tower-defence economy can be tuned via the alpha pre-factor, which is a proxy of gameplay difficulty. Set alpha to zero and the game becomes trivially easy to win as all defenders are practically free to purchase. Set alpha very high and the game becomes impossible to win, as enemy bounties cannot support the sustained investment in defences required to keep up with enemy waves of increasing difficulty. The beta pre-factor offers a way to scale the unit of currency but has no impact on game mechanics.</p>

<h2>Path coverage</h2>

<p>To calculate P(in range), we simply ask what the probability is that an enemy, placed at random along its path of attack, is in range of the defender. Since the enemy traverses the path at uniform speed, this simplifies to asking what fraction of the path is in range of the defender. Of course, we don't know where the defender is going to be placed, but the player will place it somewhere along the path. We first sample a number of positions on the path, for each position obtaining the path length in range of the defender. The path length in range is obtained by substituting the parametrised line equation for that segment into the circle equation for that defender position and solving it using the quadratic formula. The on-path location which maximises in-range path length is then used as a starting point for a gradient descent to explore whether a more optimal position may be found off-path. This is carried out in a pre-calculation step and stored as a look-up table. For our given path shape, the result looks as follows</p>

<div style="max-width: 600px; margin: 2em auto;">
    <div id="pathCoveragePlot"></div> <!-- Plotly targets divs -->
</div>
<p style="text-align: center; font-size: 0.9em;">Figure 1: Path coverage fraction vs. defender range.</p>

<p>The graph shows a few different regimes. The first regime starts at a range equal to the size of the exclusion zone, i.e., the distance from the path within which no defenders may be placed. Any defender with a range of that size or less could not achieve overlap with the path. To first-order approximation, the overlap grows linearly with range in the first regime. This regime is indicated on the map below by red dots. In this regime, defenders need to be placed in 'hot spots', corresponding to parts of the path with high radii of curvature. Note that our path has a complex winding part and a straight part, we can refer to these as the knot and the string. The second regime occurs when the range gets large enough that we no longer need to concern ourselves with the complex winding part of the path, since the entire knot falls within range. This marks the start of the second regime, indicated by blue dots on the map below. Here, the optimal defender positions are not in hot spots but seem to follow a centre of mass approach, capturing the knot in all cases while expanding range to capture more additional string as well. The second regime transitions into the third regime around the range corresponding to the theoretical minimum radius of a freely placed circle which covers our path entirely. The third regime corresponds to a full coverage of the entire path. The following map shows the calculated optimal defender positions for range values up to 500 pixels. Larger ranges have wider error bars on their optimal positions and are therefore less informative.</p>
<div id="mapContainer" style="position: relative; width: 600px; height: 600px; margin: 2em auto; border: 1px solid #ccc;">
    <img id="mapImage" src="../assets/images/map.png" alt="Game Map" style="display: block; width: 100%; height: 100%; object-fit: contain;">
    <canvas id="optimumPositionsCanvas" width="600" height="600" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
</div>
<p style="text-align: center; font-size: 0.9em;">Figure 2: Optimal defender placement positions. Red dots are below a threshold range; blue dots above it. The blue circle indicates the smallest defender range in the second regime, centred on its optimum position. Note that the blue circle covers the complex turns of the path almost entirely.</p>
<!-- End Map Visualization Section -->

<h2>Break-even condition</h2>

<p>We have the pre-factor \(\alpha\) which sets gameplay difficulty by linking defender cost to earning rate. We can now calculate the theoretical break-even point \(\alpha_0\) at which the resources generated from completing wave \(n\) exactly pay for the required additional defence investment needed to survive the next wave, \(n+1\).</p>

<p>Let \(T\) represent the time window available for clearing enemies as they traverse the path and before they reach the base. We define this timescale \(T\) as being constant from wave to wave. If an earning rate of \(R_n\) was sufficient to just clear the enemies within time \(T\), then, since each wave grows in difficulty by a factor \(f\), in order to clear the next wave requires an earning rate scaled by \(f\) as well, i.e., \( R_{n+1} = f R_n \), and to buy this additional earning rate costs</p>
\[ \Delta C = \alpha (f - 1) R_n \tag{16} \]
<p>Since we are operating at break-even condition, we have cleared wave \(n\) in exactly time \(T\), meaning that the total bounty of the wave is set equal to \(R_n T\). This makes the break-even value for \(\alpha_0\)</p>
\[ \alpha_0 = \frac{T}{f - 1} \tag{18} \]

<p>To obtain a value for \(\alpha_0\), we take \(T\) to be the time during which enemies in a wave are available for killing and the last enemy has not yet reached the base, i.e. \(T \approx L / s_{min}\).</p>

<!-- Script to fetch data and render plot with Plotly.js -->
<script>
  const plotDiv = document.getElementById('pathCoveragePlot');

  // Function to fetch and parse path coverage CSV
  function fetchPathCoverageData() {
      return fetch('../assets/paths/path-coverage.csv')
          .then(response => {
              if (!response.ok) {
                  throw new Error(`HTTP error fetching coverage data! status: ${response.status}`);
              }
              return response.text();
          })
          .then(csvText => {
              const lines = csvText.trim().split('\n');
              const xData = [];
              const yData = [];
              for (let i = 1; i < lines.length; i++) { // Skip header
                  const columns = lines[i].split(',');
                  if (columns.length === 2) {
                      const range = parseInt(columns[0]);
                      const coverage = parseFloat(columns[1]);
                      if (!isNaN(range) && !isNaN(coverage)) {
                          xData.push(range);
                          yData.push(coverage);
                      }
                  }
              }
              return { xData, yData };
          });
  }

  // Function to fetch level data JSON
  function fetchLevelData() {
      return fetch('../assets/level1.json') // Fetch level1.json
          .then(response => {
              if (!response.ok) {
                  throw new Error(`HTTP error fetching level data! status: ${response.status}`);
              }
              return response.json();
          });
  }

  // Use Promise.all to wait for both fetches
  Promise.all([fetchPathCoverageData(), fetchLevelData()])
    .then(([coverageData, levelData]) => {
      // Both fetches succeeded, data is available here
      const { xData, yData } = coverageData;
      const exclusionRadius = levelData?.pathExclusionRadius;

      if (typeof exclusionRadius !== 'number') {
          throw new Error('pathExclusionRadius not found or not a number in level1.json');
      }

      // Define endpoints for the reference line directly
      const linearX = [exclusionRadius, mapRangeThreshold];
      const linearY = [0, 0.72];

      const trace1 = {
          x: xData,
          y: yData,
          mode: 'lines',
          type: 'scatter',
          name: 'Coverage Fraction',
          line: { color: 'rgb(75, 192, 192)' },
          cliponaxis: false
      };

      const trace2 = {
          x: linearX, // Use the 2-point array
          y: linearY, // Use the 2-point array
          mode: 'lines',
          type: 'scatter',
          name: 'Linear reference',
          line: { color: 'black', width: 1.5 },
          cliponaxis: false
      };

      const layout = {
          font: { family: "'Latin Modern Roman', serif", size: 14 },
          xaxis: {
              title: 'Defender range (pixels)',
              range: [0, 1000],
              dtick: 200,
              titlefont: { family: "'Latin Modern Roman', serif" },
              tickfont: { family: "'Latin Modern Roman', serif" },
              showline: true,
              linecolor: 'black',
              linewidth: 1,
              mirror: true
          },
          yaxis: {
              title: 'Fraction of path in range',
              range: [0, 1.05],
              dtick: 0.2,
              titlefont: { family: "'Latin Modern Roman', serif" },
              tickfont: { family: "'Latin Modern Roman', serif" },
              showline: true,
              linecolor: 'black',
              linewidth: 1,
              mirror: true
          },
          margin: { l: 50, r: 20, t: 30, b: 50, pad: 0 },
          showlegend: true,
          legend: {
              font: { family: "'Latin Modern Roman', serif" },
              x: 0.05,
              y: 0.95,
              xanchor: 'left',
              yanchor: 'top'
          },
          layer: 'below traces',
          shapes: [
            {
              type: 'line',
              x0: 733,
              y0: 0,
              x1: 733,
              y1: 1.05,
              yref: 'y',
              line: {
                color: 'black', // Changed from grey to black
                width: 2,
                dash: 'dash'
              }
            },
            {
              type: 'line',
              x0: exclusionRadius, // Use fetched value
              y0: 0,
              x1: exclusionRadius, // Use fetched value
              y1: 1,
              yref: 'paper',
              line: {
                color: 'black', // Changed from red to black
                width: 2,
                dash: 'dash'
              }
            },
            {
              // New line for the specified range threshold
              type: 'line',
              x0: mapRangeThreshold, // Use variable
              y0: 0,
              x1: mapRangeThreshold, // Use variable
              y1: 1,
              yref: 'paper',
              line: {
                color: 'black',
                width: 2,
                dash: 'dash'
              }
            }
          ]
      };

      Plotly.newPlot(plotDiv, [trace1, trace2], layout);
    })
    .catch(error => {
      // Handle errors from either fetch or processing
      console.error('Error fetching data or rendering plot:', error);
      if (plotDiv) {
          let errorMsgElement = plotDiv.querySelector('.chart-error-msg');
          if (!errorMsgElement) {
              errorMsgElement = document.createElement('p');
              errorMsgElement.style.color = 'red';
              errorMsgElement.classList.add('chart-error-msg');
              plotDiv.appendChild(errorMsgElement);
          }
          errorMsgElement.textContent = 'Error loading chart: ' + error.message + '. Check console.';
      }
    });

  // --- Script for Map Visualization ---
  const mapImage = document.getElementById('mapImage');
  const mapCanvas = document.getElementById('optimumPositionsCanvas');
  const mapCtx = mapCanvas.getContext('2d');
  const optimalPosDataPath = '../assets/paths/path-optimums.csv';
  const mapRangeThreshold = 468; // Define threshold variable here

  // Ensure image is loaded before drawing (important for dimensions if not hardcoded)
  mapImage.onload = () => {
      console.log("Map image loaded. Fetching optimum positions...");
      fetchOptimalPositions(mapRangeThreshold); // Pass variable
  };
  // Handle cases where image might already be loaded (e.g., from cache)
  if (mapImage.complete && mapImage.naturalHeight !== 0) {
       console.log("Map image already complete. Fetching optimum positions...");
       fetchOptimalPositions(mapRangeThreshold); // Pass variable
  }
  mapImage.onerror = () => {
      console.error("Failed to load map image:", mapImage.src);
      const mapContainer = document.getElementById('mapContainer');
      if(mapContainer){
          mapContainer.innerHTML = '<p style="color:red;">Error loading map image. Check path and console.</p>';
      }
  }

  // Use async function to handle fetching dependencies sequentially
  // Accept threshold as an argument
  async function fetchOptimalPositions(threshold) { 
      try {
          // --- Fetch level data first ---
          const levelResponse = await fetch('../assets/level1.json');
          if (!levelResponse.ok) {
              throw new Error(`HTTP error fetching level data! status: ${levelResponse.status}`);
          }
          const levelData = await levelResponse.json();
          const exclusionRadius = levelData?.pathExclusionRadius;

          if (typeof exclusionRadius !== 'number') {
              throw new Error('pathExclusionRadius not found or not a number in level1.json');
          }
          // ---------------------------

          // --- Now fetch optimum positions ---
          const optimumsResponse = await fetch(optimalPosDataPath);
          if (!optimumsResponse.ok) {
              throw new Error(`HTTP error fetching optimum positions! status: ${optimumsResponse.status} - Check path: ${optimalPosDataPath}`);
          }
          const csvText = await optimumsResponse.text();
          // -----------------------------

          const positions = [];
          const lines = csvText.trim().split('\n');
          // Skip header
          for (let i = 1; i < lines.length; i++) {
              const columns = lines[i].split(',');
              if (columns.length === 3) {
                  const range = parseInt(columns[0]); // Parse range
                  const x = parseFloat(columns[1]);
                  const y = parseFloat(columns[2]);
                  if (!isNaN(range) && !isNaN(x) && !isNaN(y)) {
                      positions.push({ range, x, y }); // Store range, x, y
                  }
              }
          }
          // Filter using only the lower bound (exclusionRadius)
          const filteredPositions = positions.filter(pos => pos.range > exclusionRadius);

          // Sort by range to find the first one >= threshold
          filteredPositions.sort((a, b) => a.range - b.range);
          const targetPosition = filteredPositions.find(pos => pos.range >= threshold);

          // Pass the target position (or undefined if not found) to the drawing function
          drawOptimalPositions(filteredPositions, threshold, targetPosition); 

      } catch (error) {
          // --- Unified error handling ---
          console.error('Error fetching data or processing positions:', error);
          mapCtx.fillStyle = 'red';
          mapCtx.font = '12px sans-serif';
          mapCtx.fillText('Error loading optimal positions. See console.', 10, 20);
          // --------------------------
      }
  }

  function drawOptimalPositions(positions, rangeThreshold, targetPosition) {
      // Define original (data) and display dimensions
      const originalWidth = 1024;
      const originalHeight = 1024;
      const displayWidth = 600;
      const displayHeight = 600;

      // Set canvas size explicitly
      mapCanvas.width = displayWidth;
      mapCanvas.height = displayHeight;
      
      mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height); // Clear previous drawings
      const dotRadius = 2; // Size of the position dots

      // Calculate scaling factors
      const scaleX = displayWidth / originalWidth;
      const scaleY = displayHeight / originalHeight;

      // --- Draw all the position dots first ---
      positions.forEach(pos => {
          if (pos.range < rangeThreshold) {
              mapCtx.fillStyle = 'red';
          } else {
              mapCtx.fillStyle = 'blue';
          }
          const scaledX = pos.x * scaleX;
          const scaledY = pos.y * scaleY;
          mapCtx.beginPath();
          mapCtx.arc(scaledX, scaledY, dotRadius, 0, 2 * Math.PI);
          mapCtx.fill(); 
      });
      // --- End drawing dots ---
       
      // --- Draw the target circle outline --- 
      if (targetPosition) {
          console.log("Drawing target circle for range:", targetPosition.range);
          const scaledCenterX = targetPosition.x * scaleX;
          const scaledCenterY = targetPosition.y * scaleY;
          // Scale the radius using the same factor as x-coordinates (assuming uniform scaling)
          const scaledRadius = targetPosition.range * scaleX; 

          mapCtx.beginPath();
          mapCtx.arc(scaledCenterX, scaledCenterY, scaledRadius, 0, 2 * Math.PI);
          mapCtx.strokeStyle = 'blue'; // Blue outline
          mapCtx.lineWidth = 1; // Thin outline
          mapCtx.stroke(); // Draw the outline, don't fill
      }
      // --- End drawing circle --- 
      
      console.log(`Finished drawing optimal positions. Threshold: ${rangeThreshold}px`);
  }
  // --------------------------------

</script>

<!-- Script to trigger KaTeX rendering -->
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '\\[', right: '\\]', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false}
      ],
      throwOnError : false
    });
  });
</script>

</body>
</html>