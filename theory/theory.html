<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower defence theory</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Latin+Modern+Roman&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous">
    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
    <!-- Include Plotly.js -->
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
    <style>
        body { font-family: 'Latin Modern Roman', serif; font-size: 1.1em; line-height: 1.6; padding: 2em; max-width: 800px; margin: auto; }
        .katex { font-size: inherit; } /* Make KaTeX inherit body font size */
        .katex-display { display: block; margin: 1em 0; text-align: center; }
        h1 { text-align: center; }
    </style>
</head>
<body>

<h1>Tower-defence theory</h1>

<p style="text-align: center; font-size: 0.9em; margin-top: 0.5em; margin-bottom: 1.5em;">
    Dr. S. ten Cate<br>
    <a href="mailto:s.tencate@outlook.com" style="color: inherit; text-decoration: none;">s.tencate@outlook.com</a>
</p>

<h2>Wave generation</h2>

<p>We generate waves of enemies according to an increasing difficulty score. The difficulty score \(W_n\) of a given wave \(n\) is given by the initial difficulty \(W_0\) multiplied by a difficulty increase factor \(f\) raised to the power of the wave number \(n\):</p>
\[ W_n = W_0 f^n \tag{1} \]

<p>This gives the total difficulty for a given wave such that we get waves of exponentially increasing difficulty. To now turn this into a selection of enemies for the wave, we assign each enemy type \(i\) a difficulty score \(w_i\). We assert that an enemy is more difficult to defeat the greater its speed \(s_i\) and health \(h_i\). Since the difficulty has an arbitrary scale, we simply assign the per-enemy difficulty score for type \(i\) as \(w_i = h_i s_i\). The total difficulty score of the wave is the sum of the difficulty scores of all the enemy types in the wave.</p>

\[ \sum_{i=1}^{N} (h_i s_i) = W_0 f^n \tag{2} \]

<p>We then select the enemy types for the wave such that the sum of the difficulty scores of the selected enemy types equals the total difficulty score of the wave. We make the selection by assigning each enemy type an equal probability of spawning, and then iterate by adding and removing enemies until we get within a tolerance of the target wave difficulty.</p>

<h2>Defender valuation</h2>

<p>It would be good to have algorithmically determined defender prices, which reflect their usefulness against enemies.To achieve this, we can take an idea from business valuation. For a business, we might look at their yearly profit, multiply that by a factor such as 15, and the result would be a valuation of the business. That's what you might expect to pay for the business if you wanted to buy it.</p>

<p>In terms of the tower defence game, then, I know that the defenders will earn money by killing enemies. That's because the enemies have a bounty which gets added to your funds when they die. So, the idea is to set the defender's cost, \(C\), proportional to its expected earning rate, \(R\), using a tunable pre-factor, \(\alpha\).</p>

\[ C = \alpha R \tag{3} \]

<p>Now, to calculate the expected earning power of a given defender, we start simply with the case of a single defender of a given type versus a single enemy of a given type. Once we have that, then we can use an expectation value across all enemy types to get the expected earning power of that defender.</p>

<p>So, say we have a single defender versus a single enemy. We can then set up a probability chain similar to the Drake equation to find the earning rate \(R\) for this specific pairing. We start with the ideal earning rate, \(R^*\), which assumes the defender has the enemy in range until it kills the enemy and obtains the bounty. We then multiply this ideal rate by the probability that the enemy is in range, \(P(\text{in range})\), and by the probability that the kill completes while the enemy is still in range, \(P(\text{kill completes})\).</p>

\[ R = R^* P(\text{in range}) P(\text{kill completes}) \tag{4} \]

<p>The ideal earning rate, \(R^*\), is simply the enemy bounty, \(B\), divided by the time it takes the defender to kill the enemy, \(T_k\). While the bounty \(B\) can be set manually, it can also be algorithmically determined based on enemy properties, for example, making it proportional (via a constant \(\beta\)) to the enemy's speed \(s\) and health \(h\). The time to kill, \(T_k\), depends on the enemy health \(h\), the defender's damage per hit \(D\), and the defender's attack rate \(r\). Specifically, we need the number of hits required, which is the health divided by damage, rounded up to the nearest integer (ceiling function), divided by the attack rate. This ideal earning rate assumes an enemy is in range of the defender and that it stays in range until the kill completes.</p>

\[ R^* = \frac{B}{T_k} \tag{5} \]
\[ B = \beta s h \tag{6} \]
\[ T_k = \left\lceil \frac{h}{D} \right\rceil / r \tag{7} \]

<p>To calculate P(in range), we simply ask what the probability is that an enemy, placed at random along its path of attack, is in range of the defender. Since the enemy traverses the path at uniform speed, this simplifies to asking what fraction of the path is in range of the defender. Of course, we don't know where the defender is going to be placed, but the player will place it somewhere along the path. We thus need to consider all positions along the path, for each position obtain the path length in range of the defender, and average the results. The path length in range is obtained by substituting the parametrised line equation for that segment into the circle equation for that defender position and solving it using the quadratic formula. This is carried out in a pre-calculation step and stored as a look-up table. For our given path shape, the result looks as follows</p>

<div style="max-width: 600px; margin: 2em auto;">
    <div id="pathCoveragePlot"></div> <!-- Plotly targets divs -->
</div>

<p>The vertical dashed line indicates the theoretical minimum radius of a freely placed circle which covers our path entirely. We observe the actual fraction to reach unity at ranges a little greater than the theoretical minimum due to our choosing the defender to be path-bound rather than freely placed.</p>

<p>Next, we need to calculate \(P(\text{kill completes})\). This probability accounts for the fact that an enemy moves through the range, so will only stay in range for a limited time, \(T_r\). If the time in range is shorter than the time to kill \(T_k\), then the defender cannot complete the kill. However, the defender can reduce the enemy health by a percentage. We can choose to consider that health reduction a probability to complete the kill, since we can choose to view a 100% chance of a 50% health reduction as mathematically equivalent to a 50% chance of a 100% health reduction. The time in range can be expressed in terms of the total path length \(L\).</p>

\[ P(\text{kill completes}) = \min\left( \frac{T_r}{T_k}, 1 \right) \tag{8} \]
\[ T_r = P(\text{in range}) \frac{L}{s} \tag{9} \]

<p>Now, as mentioned in the above, this gives the earning rate of a single defender type against a single enemy type.</p>

\[ C = \alpha B P(\text{in range}) \frac{r}{\left\lceil \frac{h}{D} \right\rceil} \min\left( \frac{P(\text{in range}) L r}{s \left\lceil \frac{h}{D} \right\rceil}, 1 \right) \tag{10} \]

<p>We can then take the expectation value for the cost of this defender type by multiplying the cost \(C_j\) (calculated using Eq. 8 for each enemy type \(j\) with its specific health \(h_j\) and speed \(s_j\)) by the probability \(P(j)\) of spawning that enemy type, and summing over all \(N\) enemy types. Assuming equal probability \(P(j)=1/N\) for all types, and using the equation for the per-enemy bounty \(B\), this yields the expected cost \(\mathbb{E}[C]\):</p>

\[ \mathbb{E}[C] = \frac{\alpha \beta P(\text{in range}) r}{N} \sum_{j=1}^{N} \left[ \frac{s_j h_j}{\lceil h_j/D \rceil} \min\left( \frac{P(\text{in range}) L r}{s_j \lceil h_j/D \rceil}, 1 \right) \right] \tag{11} \]

<p>The result provides a way of automatically setting the defender cost based on the path shape, the defender properties (range, damage per hit, attack rate), and the enemy properties (health, speed). The tower-defence economy can be tuned via the alpha pre-factor, which is a proxy of gameplay difficulty. Set alpha to zero and the game becomes trivially easy to win as all defenders are practically free to purchase. Set alpha very high and the game becomes impossible to win, as enemy bounties cannot support the sustained investment in defences required to keep up with enemy waves of increasing difficulty. The beta pre-factor offers a way to scale the unit of currency but has no impact on game mechanics.</p>

<h2>Break-even condition</h2>

<p>We have the pre-factor alpha which sets gameplay difficulty. We can now calculate the theoretical break-even point for alpha at which the bounty earnings from a given wave exactly equal the required defence investment to survive the next wave.</p>

<p>Particularly, we use an exponentially increasing wave difficulty.</p>

<!-- Script to fetch data and render plot with Plotly.js -->
<script>
  const plotDiv = document.getElementById('pathCoveragePlot');

  fetch('../assets/paths/path-coverage.csv')
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status} - Check if file exists and is served correctly.`);
      }
      return response.text();
    })
    .then(csvText => {
      const lines = csvText.trim().split('\n');
      const xData = [];
      const yData = [];

      // Skip header row
      for (let i = 1; i < lines.length; i++) {
          const columns = lines[i].split(',');
          if (columns.length === 2) {
              const range = parseInt(columns[0]);
              const coverage = parseFloat(columns[1]);
              if (!isNaN(range) && !isNaN(coverage)) { // Basic validation
                 xData.push(range);
                 yData.push(coverage);
              }
          }
      }

      const trace1 = {
          x: xData,
          y: yData,
          mode: 'lines',
          type: 'scatter',
          name: 'Path Coverage Fraction',
          line: { color: 'rgb(75, 192, 192)' },
          cliponaxis: false
      };

      const layout = {
          font: { family: "'Latin Modern Roman', serif", size: 14 }, // Default font
          xaxis: {
              title: 'Defender range (pixels)',
              range: [0, 1000],
              dtick: 200,
              titlefont: { family: "'Latin Modern Roman', serif" },
              tickfont: { family: "'Latin Modern Roman', serif" },
              showline: true,
              linecolor: 'black',
              linewidth: 1,
              mirror: true
          },
          yaxis: {
              title: 'Fraction of path in range',
              range: [0, 1.05],   // Extend range significantly to 1.2
              dtick: 0.2,
              titlefont: { family: "'Latin Modern Roman', serif" },
              tickfont: { family: "'Latin Modern Roman', serif" },
              showline: true,
              linecolor: 'black',
              linewidth: 1,
              mirror: true
          },
          margin: { l: 50, r: 20, t: 30, b: 50, pad: 0 },
          showlegend: false,
          legend: { font: { family: "'Latin Modern Roman', serif" } },
          layer: 'below traces', // Draw axes/box lines below data line
          shapes: [
            {
              type: 'line',
              x0: 733,
              y0: 0,
              x1: 733,
              y1: 1.2,
              line: {
                color: 'grey',
                width: 2,
                dash: 'dash'
              }
            }
          ]
      };

      Plotly.newPlot(plotDiv, [trace1], layout);
    })
    .catch(error => {
      console.error('Error fetching or parsing CSV data:', error);
      if (plotDiv) {
          let errorMsgElement = plotDiv.querySelector('.chart-error-msg');
          if (!errorMsgElement) {
              errorMsgElement = document.createElement('p');
              errorMsgElement.style.color = 'red';
              errorMsgElement.classList.add('chart-error-msg');
              plotDiv.appendChild(errorMsgElement);
          }
          errorMsgElement.textContent = 'Error loading chart data: ' + error.message + ' Please ensure the file is served via a web server (not file://) and check the console.';
      }
    });
</script>

<!-- Script to trigger KaTeX rendering -->
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '\\[', right: '\\]', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false}
      ],
      throwOnError : false
    });
  });
</script>

</body>
</html>